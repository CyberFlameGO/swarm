<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.6 at 2017-11-20 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Swarm &#x2013; CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20171120" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                Swarm
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2017-11-20</span>
                  &nbsp;| <span id="projectVersion">Version: 2.8.3-SNAPSHOT</span>
                      </div>
            <div class="xright">                    <a href="./" title="Swarm">Swarm</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                          <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                          <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
            <strong>CPD</strong>
          </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD">PMD</a>
            </li>
                      <li class="none">
                          <a href="findbugs.html" title="FindBugs">FindBugs</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="cobertura/index.html" title="Cobertura Test Coverage">Cobertura Test Coverage</a>
            </li>
                      <li class="none">
                          <a href="javancss.html" title="JavaNCSS Report">JavaNCSS Report</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.3.2.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/rsam/RsamRatioPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/rsam/RsamRatioPanel.html#L93">93</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/rsam/RsamViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/rsam/RsamViewPanel.html#L93">93</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public RsamRatioPanel(RsamViewSettings s) {
    settings = s;

    setupMouseHandler();
    settings.addListener(this);
  }


  private void setupMouseHandler() {
    Cursor crosshair = new Cursor(Cursor.CROSSHAIR_CURSOR);
    this.setCursor(crosshair);

    this.addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent e) {
        UiTime.touchTime();
        if (SwingUtilities.isRightMouseButton(e)) {
          settings.cycleType();
        }
      }
    });
  }


  /**
   * Set the working flag. This flag indicates whether data are being loaded
   * for this panel.
   * 
   * @param b
   *          the working flag state
   */
  public void setWorking(boolean b) {
    working = b;
  }


  public String getChannel() {
    return channel;
  }

  public void setChannel(String c) {
    channel = c;
  }

  public void settingsChanged() {
    processSettings();
  }


  /**
   * Set RSAM data.
   * @param data RSAM data
   * @param st start time
   * @param et end time
   */
  public void setData(RSAMData data, double st, double et) {
    this.data = data;
    startTime = st;
    endTime = et;
    processSettings();
  }

  private synchronized void setImage(BufferedImage bi) {
    image = bi;
  }

  private synchronized BufferedImage getImage() {
    return image;
  }

  private void createImage() {
    final Runnable r = new Runnable() {
      public void run() {
        if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
          BufferedImage bi =
              new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_4BYTE_ABGR);
          Graphics2D ig = (Graphics2D) bi.getGraphics();
          constructPlot(ig);
          setImage(bi);
        }
      }
    };

    if (SwingUtilities.isEventDispatchThread()) {
      SwingWorker worker = new SwingWorker() {
        public Object construct() {
          r.run();
          return null;
        }

        public void finished() {
          repaint();
        }
      };
      worker.start();
    } else {
      r.run();
    }
  }

  /**
   * Does NOT call repaint for efficiency purposes, that is left to the
   * container.
   */
  private void processSettings() {
    if (data == null || data.getData() == null || data.getData().rows() == 0) {
      return;
    }

    createImage();
  }

  /**
   * Paints the component on the specified graphics context.
   * 
   * @param g
   *          the graphics context
   */
  public void paint(Graphics g) {
    if (!(g instanceof Graphics2D)) {
      throw new RuntimeException(&quot;Fatal error in RsamViewPanel.paint()&quot;);
    }

    Graphics2D g2 = (Graphics2D) g;
    Dimension dim = this.getSize();

    if (data == null) {
      g2.setColor(BACKGROUND_COLOR);
      g2.fillRect(0, 0, dim.width, dim.height);
      g2.setColor(Color.black);
      if (working) {
        g2.drawString(&quot;Retrieving data...&quot;, dim.width / 2 - 50, dim.height / 2);
      } else {
        String error = &quot;No RSAM data.&quot;;
        if (channel != null) {
          error = &quot;No RSAM data for &quot; + channel + &quot;.&quot;;
        }
        int w = g2.getFontMetrics().stringWidth(error);
        g2.drawString(error, dim.width / 2 - w / 2, dim.height / 2);
      }
    } else {
      BufferedImage bi = getImage();
      if (bi != null) {
        g2.drawImage(bi, 0, 0, null);
      }

    }
  }



  /**
   * Constructs the plot on the specified graphics context.
   * 
   * @param g2 the graphics context
   */
  private synchronized void constructPlot(Graphics2D g2) {
    Dimension dim = this.getSize();

    Plot plot = new Plot();
    plot.setBackgroundColor(BACKGROUND_COLOR);
    plot.setSize(dim);

    switch (settings.getType()) {
      case VALUES:
        plotValues(plot, data);
        break;
      case COUNTS:
        plotCounts(plot, data);
        break;
      default:
        break;
    }

    try {
      plot.render(g2);
    } catch (PlotException e) {
      e.printStackTrace();
    }
  }

  /**
   * Plots RSAM values.
   * 
   * @param data
   *          the RSAM values to plot
   */
  private void plotValues(Plot plot, RSAMData data) {
    if (data == null || data.getData() == null || data.getData().rows() == 0) {
      return;
    }

    GenericDataMatrix gdm = new GenericDataMatrix(data.getData().copy());

    gdm.despike(1, settings.valuesPeriodS);

    if (settings.detrend) {
      gdm.detrend(1);
    }

    if (settings.despike) {
      gdm.despike(1, settings.despikePeriod);
    }

    if (settings.runningMedian) {
      gdm.set2median(1, settings.runningMedianPeriodS);
    }

    if (settings.runningMean) {
      gdm.set2mean(1, settings.runningMeanPeriodS);
    }

    MatrixRenderer mr = new MatrixRenderer(gdm.getData(), false);
    double max;
    double min;
    if (settings.getAutoScale()) {
      max = gdm.max(1) + gdm.max(1) * .1;
      min = gdm.min(1) - gdm.max(1) * .1;
    } else {
      max = settings.scaleMax;
      min = settings.scaleMin;
    }

    mr.setExtents(startTime, endTime, min, max);
    mr.setLocation(X_OFFSET, Y_OFFSET, this.getWidth() - X_OFFSET - RIGHT_WIDTH,
        this.getHeight() - Y_OFFSET - BOTTOM_HEIGHT);
    mr.createDefaultAxis();
    mr.setXAxisToTime(8, true, true);

    mr.getAxis().setLeftLabelAsText(&quot;RSAM Values&quot;, -55, Color.BLACK);

    mr.createDefaultLineRenderers(Color.blue);
    plot.addRenderer(mr);

/*    if (settings.filterOn) {
      plot.addRenderer(getFilterLabel(getWidth() - RIGHT_WIDTH, getHeight() - BOTTOM_HEIGHT,
          TextRenderer.RIGHT, TextRenderer.BOTTOM));
    }*/
  }

  /**
   * Plots RSAM counts.
   * 
   * @param data the RSAM values to plot
   */
  private void plotCounts(Plot plot, RSAMData data) {
    if (data == null || data.getData() == null || data.getData().rows() == 0) {
      return;
    }

    // get the relevant information for this channel
    data.countEvents(settings.eventThreshold, settings.eventRatio, settings.eventMaxLengthS);

    // setup the histogram renderer with this data
    HistogramRenderer hr = new HistogramRenderer(data.getCountsHistogram(settings.binSize));
    hr.setLocation(X_OFFSET, Y_OFFSET, this.getWidth() - X_OFFSET - RIGHT_WIDTH,
        this.getHeight() - Y_OFFSET - BOTTOM_HEIGHT);
    hr.setDefaultExtents();
    hr.setMinX(startTime);
    hr.setMaxX(endTime);

    // x axis decorations
    hr.createDefaultAxis(8, 8, true, true, false, true, true, true);
    hr.setXAxisToTime(8, true, true);

    hr.getAxis().setLeftLabelAsText(&quot;Events per &quot; + settings.binSize, -55, Color.BLACK);

    DoubleMatrix2D countsData = data.getCumulativeCounts();
    if (countsData != null &amp;&amp; countsData.rows() &gt; 0) {

      double cmin = countsData.get(0, 1);
      double cmax = countsData.get(countsData.rows() - 1, 1);

      MatrixRenderer mr = new MatrixRenderer(countsData, false);
      mr.setAllVisible(true);
      mr.setLocation(X_OFFSET, Y_OFFSET, this.getWidth() - X_OFFSET - RIGHT_WIDTH,
          this.getHeight() - Y_OFFSET - BOTTOM_HEIGHT);
      mr.setExtents(startTime, endTime, cmin, cmax + 1);
      mr.createDefaultLineRenderers(Color.RED);
      ShapeRenderer[] r = mr.getLineRenderers();
      ((ShapeRenderer) r[0]).color = Color.RED;
      ((ShapeRenderer) r[0]).stroke = new BasicStroke(2.0f);

      // create the axis for the right hand side
      AxisRenderer ar = new AxisRenderer(mr);
      ar.createRightTickLabels(SmartTick.autoTick(cmin, cmax, 8, false), null);
      mr.setAxis(ar);

      hr.addRenderer(mr);
      hr.getAxis().setRightLabelAsText(&quot;Cumulative Counts&quot;);

    }
    plot.addRenderer(hr);
  }


  /**
   * Overload of Component. Always returns the developer-specified size.
   * 
   * @return the size of the component
   */
  public Dimension getPreferredSize() {
    return getSize();
  }

  /**
   * Overload of Component. Always returns the developer-specified size.
   * 
   * @return the size of the component
   */
  public Dimension getMinimumSize() {
    return getSize();
  }

  /**
   * Get filter label.
   * @param x x text location
   * @param y y text location
   * @param horizJustification horizontal justification
   * @param vertJustification vertical justification
   * @return text renderer
   */
/*  public TextRenderer getFilterLabel(int x, int y, int horizJustification, int vertJustification) {
    String ft = &quot;&quot;;
    switch (settings.filter.getType()) {
      case BANDPASS:
        ft = &quot;Band pass [&quot; + settings.filter.getCorner1() + &quot;-&quot; + settings.filter.getCorner2()
            + &quot; Hz]&quot;;
        break;
      case HIGHPASS:
        ft = &quot;High pass [&quot; + settings.filter.getCorner1() + &quot; Hz]&quot;;
        break;
      case LOWPASS:
        ft = &quot;Low pass [&quot; + settings.filter.getCorner1() + &quot; Hz]&quot;;
        break;
      default:
        break;
    }
    TextRenderer tr = new TextRenderer(x, y, ft);
    tr.horizJustification = horizJustification;
    tr.vertJustification = vertJustification;
    tr.color = Color.red;
    return tr;
  }*/
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L800">800</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L1026">1026</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    g2.drawString(label, (int) x + offset, 3 + (fm.getAscent() + offset));
  }
  
  public void setUseFilterLabel(boolean b) {
    useFilterLabel = b;
  }

  public TextRenderer getFilterLabel() {
    return getFilterLabel(xOffset + 5, 148, TextRenderer.NONE, TextRenderer.NONE);
  }

  /**
   * Get filter label.
   * @param x x text location
   * @param y y text location
   * @param horizJustification horizontal justification
   * @param vertJustification vertical justification
   * @return text renderer
   */
  public TextRenderer getFilterLabel(int x, int y, int horizJustification, int vertJustification) {
    String ft = &quot;&quot;;
    switch (settings.filter.getType()) {
      case BANDPASS:
        ft = &quot;Band pass [&quot; + settings.filter.getCorner1() + &quot;-&quot; + settings.filter.getCorner2()
            + &quot; Hz]&quot;;
        break;
      case HIGHPASS:
        ft = &quot;High pass [&quot; + settings.filter.getCorner1() + &quot; Hz]&quot;;
        break;
      case LOWPASS:
        ft = &quot;Low pass [&quot; + settings.filter.getCorner1() + &quot; Hz]&quot;;
        break;
      default:
        break;
    }
    TextRenderer tr = new TextRenderer(x, y, ft);
    tr.horizJustification = horizJustification;
    tr.vertJustification = vertJustification;
    tr.color = Color.red;
    return tr;
  }

  /**
   * Constructs the plot on the specified graphics context.
   * 
   * @param g2 the graphics context
   */
  private synchronized void constructPlot(Graphics2D g2) {
    Dimension dim = this.getSize();
    
    Plot plot = new Plot();
    plot.setBackgroundColor(backgroundColor);
    plot.setSize(dim);
    Wave renderWave = wave;
    
    if (settings.filterOn) {
      renderWave = new Wave(wave);
      filter(renderWave);
    }
    switch (settings.viewType) {
      case WAVE:
        plotWave(plot, renderWave);
        break;
      case SPECTRA:
        plotSpectra(plot, renderWave);
        break;
      case SPECTROGRAM:
        plotSpectrogram(plot, renderWave);
        break;
      case PARTICLE_MOTION:
        plotParticleMotion(plot, renderWave);
        break;
      default:
        break;
    }

    try {
      plot.render(g2);
    } catch (PlotException e) {
      e.printStackTrace();
    }
    
  }

  /**
   * Plots a wave.
   * 
   * @param renderWave the wave to plot
   */
  protected void plotWave(Plot plot, Wave renderWave) {
    if (renderWave == null || renderWave.numSamples() == 0) {
      return;
    }

    SliceWave wv = new SliceWave(renderWave);
    wv.setSlice(startTime, endTime);

    double offset = 0;
    double multiplier = 1;
    Metadata md = swarmConfig.getMetadata(channel);

    if (settings.useUnits &amp;&amp; md != null) {
      offset = md.getOffset();
      multiplier = md.getMultiplier();
    }

    double bias = 0;
    if (settings.removeBias) {
      bias = wv.mean();
    }
    
    double minY = (settings.minAmp - offset) / multiplier;
    double maxY = (settings.maxAmp - offset) / multiplier;

    if (settings.autoScaleAmp) {
      double[] dr = new double[] {wv.min(), wv.max()};
      if (settings.autoScaleAmpMemory) {
        minY = Math.min(minAmp, dr[0] - bias);
        maxY = Math.max(maxAmp, dr[1] - bias);
        minAmp = Math.min(minY, minAmp);
        maxAmp = Math.max(maxY, maxAmp);
      } else {
        minY = dr[0] - bias;
        maxY = dr[1] - bias;
      }
    }

    if (waveRenderer == null) {
      waveRenderer = new SliceWaveRenderer();
    }

    if (decorator != null) {
      waveRenderer.setFrameDecorator(decorator);
    }

    if (settings.useUnits &amp;&amp; md != null &amp;&amp; md.getUnit() != null) {
      waveRenderer.setYLabelText(md.getUnit());
    } else {
      waveRenderer.setYLabelText(&quot;Counts&quot;);
    }

    waveRenderer.setYAxisCoefficients(multiplier, offset);
    waveRenderer.setLocation(xOffset, yOffset, this.getWidth() - xOffset - rightWidth,
        this.getHeight() - yOffset - bottomHeight);
    waveRenderer.setYLimits(minY, maxY);
    waveRenderer.setViewTimes(startTime, endTime, &quot;&quot;);
    waveRenderer.setWave(wv);
    waveRenderer.setRemoveBias(settings.removeBias);
    if (channel != null &amp;&amp; displayTitle) {
      waveRenderer.setTitle(channel);
    }

    waveRenderer.update();
    plot.addRenderer(waveRenderer);
    if (useFilterLabel &amp;&amp; settings.filterOn) {
      plot.addRenderer(getFilterLabel(getWidth() - rightWidth, getHeight() - bottomHeight,
          TextRenderer.RIGHT, TextRenderer.BOTTOM));
    }
    translation = waveRenderer.getDefaultTranslation();
  }

  /**
   * Plots frequency spectra.
   * 
   * @param renderWave the wave to plot
   */
  private void plotSpectra(Plot plot, Wave renderWave) {
    if (renderWave == null || renderWave.numSamples() == 0) {
      return;
    }

    SliceWave wv = new SliceWave(renderWave);
    wv.setSlice(startTime, endTime);

    if (spectraRenderer == null) {
      spectraRenderer = new SpectraRenderer();
    }

    if (decorator != null) {
      spectraRenderer.setFrameDecorator(decorator);
    }

    spectraRenderer.setLocation(xOffset, yOffset, this.getWidth() - rightWidth - xOffset,
        this.getHeight() - bottomHeight - yOffset);
    spectraRenderer.setWave(wv);

    spectraRenderer.setAutoScale(settings.autoScalePower);
    spectraRenderer.setLogPower(settings.logPower);
    spectraRenderer.setLogFreq(settings.logFreq);
    spectraRenderer.setMaxFreq(settings.maxFreq);
    spectraRenderer.setMinFreq(settings.minFreq);
    spectraRenderer.setYUnitText(&quot;Power&quot;);
    if (channel != null &amp;&amp; displayTitle) {
      spectraRenderer.setTitle(channel);
    }

    spectraRenderer.update();
    if (useFilterLabel &amp;&amp; settings.filterOn) {
      plot.addRenderer(getFilterLabel(getWidth() - rightWidth, getHeight() - bottomHeight,
          TextRenderer.RIGHT, TextRenderer.BOTTOM));
    }

    translation = spectraRenderer.getDefaultTranslation();
    plot.addRenderer(spectraRenderer);
  }

  /**
   * Plots a spectrogram. TODO: Fix logPower.
   * 
   * @param renderWave the wave to plot
   */
  private void plotSpectrogram(Plot plot, Wave renderWave) {
    if (renderWave == null || renderWave.numSamples() == 0) {
      return;
    }

    SliceWave wv = new SliceWave(renderWave);
    wv.setSlice(startTime, endTime);

    if (spectrogramRenderer == null) {
      spectrogramRenderer = new SpectrogramRenderer();
    }

    if (decorator != null) {
      spectrogramRenderer.setFrameDecorator(decorator);
    }

    spectrogramRenderer.setLocation(xOffset, yOffset, this.getWidth() - rightWidth - xOffset,
        this.getHeight() - bottomHeight - yOffset);
    spectrogramRenderer.setWave(wv);

    spectrogramRenderer.setViewStartTime(startTime);
    spectrogramRenderer.setViewEndTime(endTime);
    spectrogramRenderer.setAutoScale(settings.autoScalePower);
    spectrogramRenderer.setLogPower(settings.logPower);

    spectrogramRenderer.setOverlap(settings.spectrogramOverlap);
    spectrogramRenderer.setMaxFreq(settings.maxFreq);
    spectrogramRenderer.setMinFreq(settings.minFreq);

    spectrogramRenderer.setMaxPower(settings.maxPower);
    spectrogramRenderer.setMinPower(settings.minPower);

    spectrogramRenderer.setBinSize((int) Math.pow(2,
        Math.ceil(Math.log(settings.binSize * wave.getSamplingRate()) / Math.log(2))));

    if (channel != null &amp;&amp; displayTitle) {
      spectrogramRenderer.setTitle(channel);
    }

    spectrogramRenderer.setYUnitText(&quot;Frequency (Hz)&quot;);

    spectrogramRenderer.setNfft(settings.nfft);

    double[] power = spectrogramRenderer.update();

    settings.minPower = power[0];
    settings.maxPower = power[1];

    plot.addRenderer(spectrogramRenderer);
    if (useFilterLabel &amp;&amp; settings.filterOn) {
      plot.addRenderer(getFilterLabel(getWidth() - rightWidth, getHeight() - bottomHeight,
          TextRenderer.RIGHT, TextRenderer.BOTTOM));
    }
    translation = spectrogramRenderer.getDefaultTranslation();
  }
  
  /**
   * Plot particle motion using detrended data.   
   */
  private void plotParticleMotion(Plot plot, Wave wave) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L200">200</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L297">297</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  protected void processRightMouseRelease(MouseEvent e){
    
  }

  protected void setupMouseHandler() {
    Cursor crosshair = new Cursor(Cursor.CROSSHAIR_CURSOR);
    this.setCursor(crosshair);
    this.addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent e) {
        UiTime.touchTime();

        if (SwingUtilities.isRightMouseButton(e)) {
          processRightMousePress(e);
        }

        double[] t = getTranslation();
        if (t != null) {
          int x = e.getX();
          double j2k = x * t[0] + t[1];
          if (timeSeries) {
            System.out.printf(&quot;%s UTC: %s j2k: %.3f ew: %d\n&quot;, channel, J2kSec.toDateString(j2k),
                j2k, J2kSec.asEpoch(j2k));
          }

          if (timeSeries &amp;&amp; j2k &gt;= startTime &amp;&amp; j2k &lt;= endTime) {
            fireTimePressed(e, j2k);
          }

          if (timeSeries &amp;&amp; allowDragging &amp;&amp; SwingUtilities.isLeftMouseButton(e)) {
            Dimension size = getSize();
            int y = e.getY();
            if (t != null &amp;&amp; y &gt; yOffset &amp;&amp; y &lt; (size.height - bottomHeight) &amp;&amp; x &gt; xOffset
                &amp;&amp; x &lt; size.width - rightWidth) {
              j2k1 = j2k2 = j2k;
              if (e.isControlDown()) {
                System.out.println(channel + &quot;: &quot; + J2kSec.toDateString(j2k1));
              } else if (!e.isShiftDown()) {
                highlightX1 = highlightX2 = x;
                dragging = true;
              }
            }
          }
        }

        fireMousePressed(e);
      }

      public void mouseReleased(MouseEvent e) {
        UiTime.touchTime();
        if (SwingUtilities.isLeftMouseButton(e) &amp;&amp; dragging) {
          dragging = false;
          if (j2k1 != j2k2 &amp;&amp; source != null) {
            double st = Math.min(j2k1, j2k2);
            double et = Math.max(j2k1, j2k2);
            zoom(st, et);
            fireZoomed(e, getStartTime(), getEndTime(), st, et);
          }
          repaint();
        }

        if (SwingUtilities.isRightMouseButton(e)) {
          processRightMouseRelease(e);
        }
        int mx = e.getX();
        int my = e.getY();
        if (allowClose &amp;&amp; SwingUtilities.isLeftMouseButton(e) &amp;&amp; mx &gt; getWidth() - 17
            &amp;&amp; mx &lt; getWidth() - 3 &amp;&amp; my &gt; 2 &amp;&amp; my &lt; 17) {
          fireClose();
        }
      }

      public void mouseExited(MouseEvent e) {
        WaveViewTime.fireTimeChanged(Double.NaN);
        pauseCursorMark = false;
        dragging = false;
        repaint();
      }
    });

    this.addMouseMotionListener(new MouseMotionListener() {
      public void mouseMoved(MouseEvent e) {
        UiTime.touchTime();
        processMousePosition(e.getX(), e.getY());
      }

      public void mouseDragged(MouseEvent e) {
        UiTime.touchTime();
        /*
         * // This used to be the launcher for the microview. // It was removed because it wasn't
         * very useful, but this // stub is left here in case something like it ever gets // put in
         * if (SwingUtilities.isLeftMouseButton(e) &amp;&amp; e.isControlDown() &amp;&amp; settings.type !=
         * WaveViewSettings.SPECTRA) { Dimension size = getSize(); double[] t = getTranslation();
         * int x = e.getX(); int y = e.getY(); if (t != null &amp;&amp; y &gt; Y_OFFSET &amp;&amp; y &lt; (size.height -
         * BOTTOM_HEIGHT) &amp;&amp; x &gt; X_OFFSET &amp;&amp; x &lt; size.width - RIGHT_WIDTH) { double j2k = x * t[0] +
         * t[1]; createMicroView(j2k); } }
         */

        processMousePosition(e.getX(), e.getY());
        if (SwingUtilities.isLeftMouseButton(e) &amp;&amp; !e.isControlDown() &amp;&amp; dragging) {
          double[] t = getTranslation();
          int x = e.getX();
          int y = e.getY();
          Dimension size = getSize();
          if (t != null &amp;&amp; y &gt; yOffset &amp;&amp; y &lt; (size.height - bottomHeight) &amp;&amp; x &gt; xOffset
              &amp;&amp; x &lt; size.width - rightWidth) {
            j2k2 = x * t[0] + t[1];
            highlightX2 = x;
            repaint();
          }
        }
      }
    });
  }

  /**
   * Wave zoom.
   * @param st start time
   * @param et end time
   */
  public void zoom(final double st, final double et) {
    final SwingWorker worker = new SwingWorker() {
      public Object construct() {
        Wave sw = null;
        if (source instanceof CachedDataSource) {
          sw = ((CachedDataSource) source).getBestWave(channel, st, et);
        } else {
          sw = source.getWave(channel, st, et);
        }
        setWave(sw, st, et);
        return null;
      }

      public void finished() {

        repaint();
      }
    };
    worker.start();
  }

  /**
   * Set the working flag. This flag indicates whether data are being loaded for this panel.
   * 
   * @param b the working flag state
   */
  public void setWorking(boolean b) {
    working = b;
  }

  /**
   * Set the allow dragging flag. This flag enables zoom dragging. Currently only allowed on the
   * clipboard, but could be implemented within the helicorder view.
   * 
   * @param b the allow dragging flag state
   */
  public void setAllowDragging(boolean b) {
    allowDragging = b;
  }

  public void setStatusText(StatusTextArea text) {
    statusText = text;
  }

  public int getXOffset() {
    return xOffset;
  }

  public int getYOffset() {
    return yOffset;
  }

  public WaveViewSettings getSettings() {
    return settings;
  }

  public double getStartTime() {
    return startTime;
  }

  public void setStartTime(double startTime) {
    this.startTime = startTime;
  }

  public double getEndTime() {
    return endTime;
  }

  public void setEndTime(double endTime) {
    this.endTime = endTime;
  }

  public Wave getWave() {
    return wave;
  }

  public WaveViewSettings getWaveViewSettings() {
    return settings;
  }

  public String getChannel() {
    return channel;
  }

  public void setChannel(String c) {
    channel = c;
  }

  public void setSettings(WaveViewSettings s) {
    settings = s;
    processSettings();
  }

  public SeismicDataSource getDataSource() {
    return source;
  }

  public void setDataSource(SeismicDataSource s) {
    source = s;
  }

  public void setFrameDecorator(FrameDecorator fd) {
    decorator = fd;
  }

  public void setDisplayTitle(boolean b) {
    displayTitle = b;
  }

  public void settingsChanged() {
    processSettings();
  }

  public boolean isTimeSeries() {
    return timeSeries;
  }

  /**
   * Gets the translation info for this panel. The translation info is used to convert from pixel
   * coordinates on the panel into time or data coordinates.
   * 
   * @return the transformation information
   */
  public double[] getTranslation() {
    return translation;
  }

  /**
   * Set the background color of the panel.
   * 
   * @param c the background color
   */
  public void setBackgroundColor(Color c) {
    backgroundColor = c;
  }

  public void setBottomBorderColor(Color c) {
    bottomBorderColor = c;
  }

  public void setBorderColor(Color c) {
    borderColor = c;
  }

  /**
   * Processes the mouse position variables when the cursor is over the panel. Currently, the only
   * thing this does is set the status bar text.
   * 
   * @param x the mouse x position
   * @param y the mouse y position
   */
  public boolean processMousePosition(int x, int y) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L538">538</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L679">679</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          statusText.setText(st);
        }
      });
    }

    return !status.equals(&quot; &quot;);
  }

  /**
   * Set wave.
   * @param sw wave to set to
   * @param st start time
   * @param et end time
   */
  public void setWave(Wave sw, double st, double et) {
    wave = sw;
    startTime = st;
    endTime = et;
    processSettings();
  }

  /**
   * Reset auto scale memory settings.
   */
  public void resetAutoScaleMemory() {
    minAmp = 1E300;
    maxAmp = -1E300;
    maxSpectraPower = -1E300;
    maxSpectrogramPower = -1E300;
    settings.autoScaleAmp = true;
    settings.autoScalePower = true;
    processSettings();
  }

  /**
   * Adjust scale by percent.
   * @param pct percent to scale to.
   */
  public void adjustScale(double pct) {
    double maxa = settings.autoScaleAmp ? maxAmp : settings.maxAmp;
    double mina = settings.autoScaleAmp ? minAmp : settings.minAmp;
    settings.autoScaleAmp = false;
    double range = maxa - mina;
    double center = range / 2 + mina;
    double newRange = range * pct;
    settings.minAmp = center - newRange / 2;
    settings.maxAmp = center + newRange / 2;

    if (settings.viewType == ViewType.SPECTROGRAM) {
      double maxf = settings.maxFreq * pct;
      System.out.printf(&quot;WaveViewPanel(804): maxf = %f\n&quot;, maxf);
      settings.maxFreq = (maxf &gt; wave.getSamplingRate() / 2) ? wave.getSamplingRate() / 2 : maxf;
      System.out.printf(&quot;WaveViewPanel(806): settings.maxFreq = %f\n&quot;, settings.maxFreq);

    }

    processSettings();
  }

  private synchronized void setImage(BufferedImage bi) {
    image = bi;
  }

  private synchronized BufferedImage getImage() {
    return image;
  }

  /**
   * Create image.
   */
  public void createImage() {
    final Runnable r = new Runnable() {
      public void run() {
        if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
          BufferedImage bi =
              new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_4BYTE_ABGR);
          Graphics2D ig = (Graphics2D) bi.getGraphics();
          constructPlot(ig);
          setImage(bi);
        }
      }
    };

    if (SwingUtilities.isEventDispatchThread()) {
      SwingWorker worker = new SwingWorker() {
        public Object construct() {
          r.run();
          return null;
        }

        public void finished() {
          repaint();
        }
      };
      worker.start();
    } else {

      r.run();
    }
  }

  /**
   * Does NOT call repaint for efficiency purposes, that is left to the container.
   */
  protected void processSettings() {
    if (wave == null || wave.buffer == null || wave.buffer.length == 0) {
      return;
    }

    if (settings.maxFreq &gt; wave.getNyquist()) {
      settings.maxFreq = wave.getNyquist();
    }

    switch (settings.viewType) {
      case SPECTRA:
      case PARTICLE_MOTION:
        timeSeries = false;
        break;
      default:
        timeSeries = true;
    }

    createImage();
  }

  private void filter(Wave w) {
    double mean = w.mean();

    double[] buf = new double[w.buffer.length + (int) (w.buffer.length * 0.5)];
    Arrays.fill(buf, mean);
    int trueStart = (int) (w.buffer.length * 0.25);
    for (int i = 0; i &lt; w.buffer.length; i++) {
      if (w.buffer[i] != Wave.NO_DATA) {
        buf[i + trueStart] = w.buffer[i];
      }
    }

    settings.filter.setSamplingRate(w.getSamplingRate());
    settings.filter.create();
    Filter.filter(buf, settings.filter.getSize(), settings.filter.getXCoeffs(),
        settings.filter.getYCoeffs(), settings.filter.getGain(), 0, 0);
    if (settings.zeroPhaseShift) {
      double[] buf2 = new double[buf.length];
      for (int i = 0, j = buf.length - 1; i &lt; buf.length; i++, j--) {
        buf2[j] = buf[i];
      }

      Filter.filter(buf2, settings.filter.getSize(), settings.filter.getXCoeffs(),
          settings.filter.getYCoeffs(), settings.filter.getGain(), 0, 0);

      for (int i = 0, j = buf2.length - 1 - trueStart; i &lt; w.buffer.length; i++, j--) {
        w.buffer[i] = (int) Math.round(buf2[j]);
      }
    } else {
      for (int i = 0; i &lt; w.buffer.length; i++) {
        w.buffer[i] = (int) Math.round(buf[i + trueStart]);
      }
    }
    w.invalidateStatistics();
  }

  /**
   * Annotate image with pick marks.
   * @param g2 graphics
   */
  protected void annotateImage(Graphics2D g2) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L1114">1114</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L1381">1381</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>      particleMotionRenderer.setTitle(title);
    }
    plot.addRenderer(particleMotionRenderer);
    if (useFilterLabel &amp;&amp; settings.filterOn) {
      plot.addRenderer(getFilterLabel(getWidth() - rightWidth, getHeight() - bottomHeight,
          TextRenderer.RIGHT, TextRenderer.BOTTOM));
    }
    translation = null;
  }
  
  /**
   * Paints the zoom drag box.
   * 
   * @param g2 the graphics context
   */
  private void paintDragBox(Graphics2D g2) {
    int x1 = Math.min(highlightX1, highlightX2);
    int x2 = Math.max(highlightX1, highlightX2);
    int width = x2 - x1 + 1;
    Paint pnt = g2.getPaint();
    g2.setPaint(new Color(255, 255, 0, 128));
    g2.fillRect(x1, yOffset + 1, width, getSize().height - bottomHeight - yOffset);
    g2.setPaint(pnt);
  }

  public void setCursorMark(double j2k) {
    cursorMark = j2k;
    repaint();
  }

  private void paintCursor(Graphics2D g2) {
    if (Double.isNaN(cursorMark) || cursorMark &lt; startTime || cursorMark &gt; endTime) {
      return;
    }

    double[] t = getTranslation();
    if (t == null) {
      return;
    }
    double x = (cursorMark - t[1]) / t[0];
    g2.setColor(DARK_RED);
    g2.draw(new Line2D.Double(x, yOffset + 1, x, getHeight() - bottomHeight - 1));
  }


  /**
   * Overload of Component. Always returns the developer-specified size.
   * 
   * @return the size of the component
   */
  public Dimension getPreferredSize() {
    return getSize();
  }

  /**
   * Overload of Component. Always returns the developer-specified size.
   * 
   * @return the size of the component
   */
  public Dimension getMinimumSize() {
    return getSize();
  }

  /**
   * Overload of Component. Always returns the developer-specified size.
   * 
   * @return the size of the component
   */
  public Dimension getMaximumSize() {
    return getSize();
  }

  public void setMarks(double m1, double m2) {
    mark1 = m1;
    mark2 = m2;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L720">720</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L881">881</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    if (wave == null) {
      g2.setColor(backgroundColor);
      g2.fillRect(0, 0, dim.width, dim.height);
      g2.setColor(Color.black);
      if (working) {
        g2.drawString(&quot;Retrieving data...&quot;, dim.width / 2 - 50, dim.height / 2);
      } else {
        String error = &quot;No wave data.&quot;;
        if (channel != null) {
          error = &quot;No wave data for &quot; + channel + &quot;.&quot;;
        }
        int w = g2.getFontMetrics().stringWidth(error);
        g2.drawString(error, dim.width / 2 - w / 2, dim.height / 2);
      }
    } else {
      BufferedImage bi = getImage();
      if (bi != null) {
        g2.drawImage(bi, 0, 0, null);
      }

      if (dragging) {
        paintDragBox(g2);
      }

      annotateImage(g2);


      if (!Double.isNaN(cursorMark)) {
        paintCursor(g2);
      }
    }

    if (allowClose) {
      if (closeImg == null) {
        closeImg = Icons.close_view.getImage();
      }

      g2.drawImage(closeImg, dim.width - 17, 3, null);
    }
    if (bottomBorderColor != null) {
      g2.setColor(bottomBorderColor);
      g2.drawLine(0, dim.height - 1, dim.width, dim.height - 1);
    }
    if (borderColor != null) {
      g2.setColor(borderColor);
      g2.drawRect(0, 0, dim.width - 1, dim.height - 2);
    }
  }

  /**
   * Draw pick marks.
   * @param label text to tag pick mark with
   * @param g2 graphics
   * @param time time to draw mark at in millis from 1970
   */
  private void drawPick(String label, Graphics2D g2, long time) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/event/PickBox.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/event/PickBox.html#L436">436</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveClipboardFrame.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveClipboardFrame.html#L1246">1246</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public void scaleTime(final WaveViewPanel wvp, final double pct) {
    final double st = wvp.getStartTime();
    final double et = wvp.getEndTime();
    final double[] t = new double[] {st, et};
    addHistory(wvp, t);
    final double dt = (et - st) * (1 - pct);
    final double mt = (et - st) / 2 + st;
    final double nst = mt - dt / 2;
    final double net = mt + dt / 2;
    fetchNewWave(wvp, nst, net);
  }

  /**
   * @see gov.usgs.volcanoes.swarm.event.PickToolBarListener#scaleTime(double)
   */
  public void scaleTime(final double pct) {
    for (final WaveViewPanel p : selectedSet) {
      scaleTime(p, pct);
    }
  }

  /**
   * Go back to previous selected time in wave panel.
   * @param wvp wave panel
   */
  public void back(final WaveViewPanel wvp) {
    final Stack&lt;double[]&gt; history = histories.get(wvp);
    if (history == null || history.empty()) {
      return;
    }

    final double[] t = history.pop();
    fetchNewWave(wvp, t[0], t[1]);
  }

  /**
   * @see gov.usgs.volcanoes.swarm.event.PickToolBarListener#back()
   */
  public void back() {
    for (final WaveViewPanel p : selectedSet) {
      back(p);
    }
  }

  private void shiftTime(final WaveViewPanel wvp, final double pct) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/rsam/RsamRatioFrame.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/rsam/RsamRatioFrame.html#L93">93</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/rsam/RsamViewerFrame.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/rsam/RsamViewerFrame.html#L92">92</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    viewPanel.setChannel(channel1);
    rsamPanel = new JPanel(new BorderLayout());
    rsamPanel.add(viewPanel, BorderLayout.CENTER);

    Border border = BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0, 2, 3, 3),
        LineBorder.createGrayLineBorder());
    rsamPanel.setBorder(border);

    mainPanel.add(rsamPanel, BorderLayout.CENTER);

    toolBar = SwarmUtil.createToolBar();

    JButton compXButton = SwarmUtil.createToolBarButton(Icons.xminus,
        &quot;Shrink time axis (Alt-left arrow)&quot;, new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            if (spanIndex &gt; 0) {
              settings.setSpanLength(SPANS_S[spanIndex - 1]);
            }
          }
        });
    UiUtils.mapKeyStrokeToButton(this, &quot;alt LEFT&quot;, &quot;compx&quot;, compXButton);
    toolBar.add(compXButton);

    JButton expXButton = SwarmUtil.createToolBarButton(Icons.xplus,
        &quot;Expand time axis (Alt-right arrow)&quot;, new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            if (spanIndex &lt; SPANS_S.length - 1) {
              settings.setSpanLength(SPANS_S[spanIndex + 1]);
            }
          }
        });
    UiUtils.mapKeyStrokeToButton(this, &quot;alt RIGHT&quot;, &quot;expx&quot;, expXButton);
    toolBar.add(expXButton);

    toolBar.addSeparator();

    new RsamViewSettingsToolbar(settings, toolBar, this);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L53">53</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L56">56</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  private static final Logger LOGGER = LoggerFactory.getLogger(AbstractWavePanel.class);
  public static final long serialVersionUID = -1;
  protected static SwarmConfig swarmConfig;
  /**
   * X pixel location of where the main plot axis should be located on the component.
   */
  protected int xOffset = 60;
  /**
   * Y pixel location of where the main plot axis should be located on the component.
   */
  protected int yOffset = 20;
  /** The amount of padding space on the right side. */
  protected int rightWidth = 20;
  /** The amount of padding space on the bottom. */
  protected int bottomHeight = 20;
  protected FrameDecorator decorator;
  protected SliceWaveRenderer waveRenderer;
  protected SpectrogramRenderer spectrogramRenderer;
  protected SpectraRenderer spectraRenderer;
  protected Wave wave;
  protected double startTime;
  protected double endTime;
  protected WaveViewSettings settings;
  protected double minAmp = 1E300;
  protected double maxAmp = -1E300;
  protected double maxSpectraPower = -1E300;
  protected double maxSpectrogramPower = -1E300;
  protected double[] translation;
  protected boolean timeSeries;
  protected String channel;
  /**
   * The data source to use for zoom drags. This should probably be moved from this class to follow
   * a stricter interpretation of MVC.
   */
  protected SeismicDataSource source;
  /**
   * A flag to indicate whether the plot should display a title. Currently used when the plot is on
   * the clipboard or monitor.
   */
  protected boolean displayTitle;
  protected Color backgroundColor;
  protected Color bottomBorderColor;
  protected StatusTextArea statusText;
  protected boolean allowDragging = true;
  protected boolean dragging;
  protected double j2k1;
  protected double j2k2;
  protected int highlightX1;
  protected int highlightX2;
  protected static Image closeImg;
  protected boolean allowClose;
  protected EventListenerList listeners = new EventListenerList();
  /**
   * A flag that indicates whether data are being loaded for this panel.
   */
  protected boolean working;
  /**
   * The wave is rendered to an image that is only updated when the settings change for repaint
   * efficiency.
   */
  protected BufferedImage image;
  protected double mark1 = Double.NaN;
  protected double mark2 = Double.NaN;
  protected double cursorMark = Double.NaN;
  protected boolean useFilterLabel = true;
  protected Color borderColor;
  protected static final Color DARK_RED = new Color(168, 0, 0);
  protected static final Color DARK_GREEN = new Color(0, 168, 0);

  protected boolean pauseCursorMark;
  protected double time;

  // picker
  private PickMenu pickMenu;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/chooser/WebServicesPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/chooser/WebServicesPanel.html#L130">130</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/chooser/WebServicesPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/chooser/WebServicesPanel.html#L174">174</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    String sta = &quot;&quot;;
    String loc = &quot;&quot;;
    String chan = &quot;&quot;;
    String gs = &quot;60&quot;;
    String gd = &quot;1.0&quot;;
//    String wsDataSelectUrl = getDefaultText(wsDataselectUrlField);
//    String wsStationUrl = getDefaultText(wsStationUrlField);
  String wsDataSelectUrl = &quot;&quot;;
  String wsStationUrl = &quot;&quot;;
    int index;
    if (source != null &amp;&amp; (index = source.indexOf(codeText)) != -1) {
      String[] ss =
          source.substring(index + codeText.length()).split(WebServicesSource.PARAM_SPLIT_TEXT);
      int ssIndex = 0;
      net = ss[ssIndex++];
      sta = ss[ssIndex++];
      loc = ss[ssIndex++];
      chan = ss[ssIndex++];
      gs = String.format(&quot;%.0f&quot;, Integer.parseInt(ss[ssIndex++]) / 60.0);
      gd = String.format(&quot;%.1f&quot;, Integer.parseInt(ss[ssIndex++]) / 1000.0);
      wsDataSelectUrl = ss[ssIndex++];
      wsStationUrl = ss[ssIndex++];
    }
    selectNetwork(net);
    station.setText(sta);
    location.setText(loc);
    channel.setText(chan);
    gulperSize.setText(gs);
    gulperDelay.setText(gd);
    wsDataselectUrlField.setText(wsDataSelectUrl);
    wsStationUrlField.setText(wsStationUrl);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/event/PickToolBar.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/event/PickToolBar.html#L304">304</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveClipboardFrame.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveClipboardFrame.html#L580">580</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  private void doSizePopup() {
    if (popup == null) {
      final String[] labels = new String[] {&quot;Auto&quot;, null, &quot;Tiny&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;};
      final int[] sizes = new int[] {-1, -1, 50, 100, 160, 230};
      popup = new JPopupMenu();
      final ButtonGroup group = new ButtonGroup();
      for (int i = 0; i &lt; labels.length; i++) {
        if (labels[i] != null) {
          final int size = sizes[i];
          final JRadioButtonMenuItem mi = new JRadioButtonMenuItem(labels[i]);
          mi.addActionListener(new ActionListener() {
            public void actionPerformed(final ActionEvent e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/rsam/RsamRatioPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/rsam/RsamRatioPanel.html#L162">162</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/rsam/RsamViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/rsam/RsamViewPanel.html#L162">162</a></td></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/AbstractWavePanel.html#L610">610</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/wave/WaveViewPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/wave/WaveViewPanel.html#L751">751</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  private void createImage() {
    final Runnable r = new Runnable() {
      public void run() {
        if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
          BufferedImage bi =
              new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_4BYTE_ABGR);
          Graphics2D ig = (Graphics2D) bi.getGraphics();
          constructPlot(ig);
          setImage(bi);
        }
      }
    };

    if (SwingUtilities.isEventDispatchThread()) {
      SwingWorker worker = new SwingWorker() {
        public Object construct() {
          r.run();
          return null;
        }

        public void finished() {
          repaint();
        }
      };
      worker.start();
    } else {
      r.run();
    }
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/data/fdsnWs/WebServiceStationTextClient.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/data/fdsnWs/WebServiceStationTextClient.html#L30">30</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/data/fdsnWs/WebServiceStationXmlClient.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/data/fdsnWs/WebServiceStationXmlClient.html#L48">48</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    WebServiceStationTextClient client = createClient(args);
    try {
      client.setStationList(createStationList());
      error = client.fetchStations();
      if (error == null) {
        List&lt;StationInfo&gt; stationList = client.getStationList();
        System.out.println(&quot;station count: &quot; + stationList.size());
        for (StationInfo station : stationList) {
          System.out.println(&quot;station: &quot; + station);
          client.setCurrentStation(station);
          error = client.fetchChannels();
        }
      }
    } catch (Exception ex) {
      ex.printStackTrace();
    }
    if (error != null) {
      System.out.println(error);
    } else {
      System.out.println(&quot;done&quot;);
    }
  }

  /**
   * Create the web service station client.
   * 
   * @param baseUrlText
   *          the base URL text.
   * @param net
   *          the network or null if none.
   * @param sta
   *          the station or null if none.
   * @param loc
   *          the location or null if none.
   * @param chan
   *          the channel or null if none.
   * @param date
   *          the date or null if none.
   */
  public WebServiceStationTextClient(String baseUrlText, String net, String sta, String loc,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/map/MapPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/map/MapPanel.html#L1043">1043</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/map/MapPanel.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/map/MapPanel.html#L1075">1075</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        xy = getXy(pts[i % n].x, pts[i % n].y);
        final Point thisXy = new Point();
        thisXy.x = (int) Math.round(xy.x);
        thisXy.y = (int) Math.round(xy.y);
        final double a = thisXy.x - lastXy.x;
        final double b = thisXy.y - lastXy.y;
        final double dist = Math.sqrt(a * a + b * b);
        if (dist &gt; 100) {
          gp.moveTo(thisXy.x - 2, thisXy.y - 1);
        } else {
          gp.lineTo(thisXy.x - 2, thisXy.y - 1);
        }
        lastXy = thisXy;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/heli/HelicorderViewerSettingsDialog.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/heli/HelicorderViewerSettingsDialog.html#L118">118</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/heli/HelicorderViewerSettingsDialog.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/heli/HelicorderViewerSettingsDialog.html#L139">139</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    int[] values = HelicorderViewerFrame.chunkValues;
    String[] chunks = new String[values.length];
    for (int i = 0; i &lt; chunks.length; i++) {
      chunks[i] = Integer.toString(values[i] / 60);
    }
    chunkList = new JComboBox&lt;String&gt;(chunks);

    values = HelicorderViewerFrame.spanValues;
    String[] spans = new String[values.length];
    for (int i = 0; i &lt; spans.length; i++) {
      spans[i] = Integer.toString(values[i] / 60);
    }

    spanList = new JComboBox&lt;String&gt;(spans);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.html#L194">194</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.html#L335">335</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    int insetPx = panel.getInset();

    final Point2D.Double xy =
        projection.forward(new Point2D.Double(origin.getLongitude(), origin.getLatitude()));
    final double[] ext = range.getProjectedExtents(projection);
    final double dx = (ext[1] - ext[0]);
    final double dy = (ext[3] - ext[2]);
    final Point2D.Double res = new Point2D.Double();

    res.x = (((xy.x - ext[0]) / dx) * widthPx + insetPx);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.html#L125">125</a></td></tr>
<tr class="a">
<td>gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.java</td>
<td><a href="./xref/gov/usgs/volcanoes/swarm/map/hypocenters/HypocenterLayer.html#L338">338</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>      final Point2D.Double xy = projection.forward(originLoc);

      final double[] ext = range.getProjectedExtents(projection);
      final double dx = (ext[1] - ext[0]);
      final double dy = (ext[3] - ext[2]);
      final Point2D.Double res = new Point2D.Double();
      res.x = (((xy.x - ext[0]) / dx) * widthPx + insetPx);
      res.y = ((1 - (xy.y - ext[2]) / dy) * heightPx + insetPx);</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                   2017.
          All rights reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
